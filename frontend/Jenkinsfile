pipeline {
    agent any

    triggers {
        githubPush()
    }

    environment {
        DOCKER_HOST = 'unix:///var/run/docker.sock'
        FRONTEND_DIR = "${WORKSPACE}/frontend"
        TARGET_URL = "http://52.71.206.133"
        DEPLOY_STATUS = ""
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/dev-novan']],
                    extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'frontend']],
                    userRemoteConfigs: [[
                        url: 'https://github.com/dipt4aaaa/Dishcovery_Capstone.git',
                    ]]
                ])
            }
        }

        stage('Pre-Deploy Health Check') {
            steps {
                script {
                    try {
                        def response = sh(
                            returnStdout: true, 
                            script: "curl -s -o /dev/null -w '%{http_code}' --connect-timeout 10 --max-time 30 ${TARGET_URL} || echo '000'"
                        ).trim()
                        
                        echo "Current service status: HTTP ${response}"
                        
                        if (response == "200") {
                            echo "Service is currently running and healthy"
                        } else {
                            echo "Service is not responding or unhealthy (Status: ${response})"
                        }
                    } catch (Exception e) {
                        echo "Pre-deploy health check failed: ${e.getMessage()}"
                        echo "Continuing with deployment..."
                    }
                }
            }
        }

        stage('Stop Conflicting Containers') {
            steps {
                script {
                    try {
                        sh '''
                        echo "Checking for containers using port 80..."
                        
                        # Stop any container using port 80
                        CONTAINERS_ON_PORT_80=$(docker ps --filter "publish=80" -q)
                        if [ ! -z "$CONTAINERS_ON_PORT_80" ]; then
                            echo "Found containers using port 80, stopping them..."
                            docker stop $CONTAINERS_ON_PORT_80 || true
                            docker rm $CONTAINERS_ON_PORT_80 || true
                        fi
                        
                        # Stop specific known containers
                        docker stop dishcovery_capstone_frontend_1 || true
                        docker rm dishcovery_capstone_frontend_1 || true
                        
                        echo "Port 80 cleanup completed"
                        '''
                    } catch (Exception e) {
                        echo "Container cleanup warning: ${e.getMessage()}"
                    }
                }
            }
        }

        stage('Build Frontend') {
            steps {
                dir('frontend') {
                    script {
                        try {
                            sh '''
                            echo "Building frontend image..."
                            docker-compose build frontend --no-cache
                            
                            echo "Verifying built image..."
                            docker images | grep frontend || echo "No frontend images found"
                            '''
                        } catch (Exception e) {
                            error("Frontend build failed: ${e.getMessage()}")
                        }
                    }
                }
            }
        }

        stage('Deploy Frontend') {
            steps {
                dir('frontend') {
                    script {
                        try {
                            sh '''
                            echo "Starting frontend deployment..."
                            
                            # Ensure clean state
                            docker-compose stop frontend || true
                            docker-compose rm -f frontend || true
                            
                            # Wait a moment for port to be released
                            sleep 5
                            
                            # Deploy with explicit project name to avoid conflicts
                            echo "Starting frontend container..."
                            docker-compose up -d --no-deps frontend
                            
                            # Verify container started
                            sleep 10
                            if docker-compose ps frontend | grep -q "Up"; then
                                echo "Frontend container started successfully"
                            else
                                echo "Frontend container status:"
                                docker-compose ps frontend
                                docker-compose logs frontend
                                exit 1
                            fi
                            '''
                            
                            env.DEPLOY_STATUS = "SUCCESS"
                            
                        } catch (Exception e) {
                            env.DEPLOY_STATUS = "FAILED"
                            
                            // Capture logs for debugging
                            try {
                                sh '''
                                echo "=== DEPLOYMENT FAILURE DEBUG ==="
                                echo "Docker containers:"
                                docker ps -a
                                echo "Docker-compose status:"
                                docker-compose ps
                                echo "Frontend logs:"
                                docker-compose logs frontend || true
                                echo "Port 80 usage:"
                                netstat -tlnp | grep :80 || true
                                '''
                            } catch (Exception logError) {
                                echo "Failed to capture debug logs: ${logError.getMessage()}"
                            }
                            
                            error("Frontend deployment failed: ${e.getMessage()}")
                        }
                    }
                }
            }
        }

        stage('Post-Deploy Verification') {
            steps {
                script {
                    try {
                        echo "Waiting for service to be ready..."
                        sleep(time: 30, unit: 'SECONDS')
                        
                        // Multiple attempts to check service
                        def maxAttempts = 5
                        def attempt = 1
                        def deployCheck = ""
                        
                        while (attempt <= maxAttempts) {
                            deployCheck = sh(
                                returnStdout: true, 
                                script: "curl -s -o /dev/null -w '%{http_code}' --connect-timeout 10 --max-time 30 ${TARGET_URL} || echo '000'"
                            ).trim()
                            
                            echo "Attempt ${attempt}/${maxAttempts}: HTTP Status ${deployCheck}"
                            
                            if (deployCheck == "200") {
                                echo "✅ Post-deploy verification successful!"
                                env.DEPLOY_STATUS = "VERIFIED"
                                break
                            }
                            
                            if (attempt < maxAttempts) {
                                echo "Waiting 15 seconds before retry..."
                                sleep(time: 15, unit: 'SECONDS')
                            }
                            
                            attempt++
                        }
                        
                        if (deployCheck != "200") {
                            env.DEPLOY_STATUS = "UNVERIFIED"
                            echo "⚠️ Warning: Service deployed but not responding correctly (Status: ${deployCheck})"
                            
                            // Don't fail the build, but log the issue
                            sh '''
                            echo "=== SERVICE HEALTH DEBUG ==="
                            docker-compose ps frontend
                            docker-compose logs --tail=50 frontend
                            '''
                        }
                        
                    } catch (Exception e) {
                        env.DEPLOY_STATUS = "VERIFICATION_FAILED"
                        echo "Post-deploy verification error: ${e.getMessage()}"
                        // Don't fail the build for verification issues
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // Capture final status
                try {
                    sh '''
                    echo "=== FINAL DEPLOYMENT STATUS ==="
                    echo "Running containers:"
                    docker ps | grep frontend || echo "No frontend containers running"
                    echo "Port 80 status:"
                    netstat -tlnp | grep :80 || echo "Port 80 not in use"
                    '''
                } catch (Exception e) {
                    echo "Failed to capture final status: ${e.getMessage()}"
                }
            }
            cleanWs()
        }
        
        success {
            script {
                def message = "✅ Frontend deployed successfully: ${env.BUILD_URL}"
                if (env.DEPLOY_STATUS == "VERIFIED") {
                    message += " | ✅ Service verified at ${TARGET_URL}"
                } else {
                    message += " | ⚠️ Service deployed but verification pending at ${TARGET_URL}"
                }
                
                try {
                    slackSend(color: 'good', message: message)
                } catch (Exception e) {
                    echo "Slack notification failed: ${e.getMessage()}"
                }
            }
        }
        
        failure {
            script {
                def status = env.DEPLOY_STATUS ?: 'UNKNOWN'
                def message = "❌ Frontend deployment failed: ${env.BUILD_URL} | Status: ${status}"
                
                try {
                    slackSend(color: 'danger', message: message)
                } catch (Exception e) {
                    echo "Slack notification failed: ${e.getMessage()}"
                }
            }
        }
    }
}